//opencv
#include "opencv2/opencv.hpp"
#include <opencv2/video/background_segm.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <string>
#include <fstream>

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;



// Global variables
Mat primeFrame; //current frame
Rect rect_for_frame(340, 150, 260, 210);
Rect rect_for_top(0, 0, 260, 52);
Rect rect_for_middle1(0, 52, 260, 52);
Rect rect_for_middle2(0, 103, 260, 52);
Rect rect_for_bottom(0, 154, 260, 54);
Ptr<BackgroundSubtractor> pMOG; //MOG2 Background subtractor
int keyboard; //input from keyboard
int numberOfprint = 0;

void onMouse(int event, int x, int y, int, void*);
void processVideo(char* videoFilename);
void slider(Mat image, int& min, int& max, int proc)
{
	vector<Mat> temp;
	vector<int> GistBlue(256);
	vector<int> GistGreen(256);
	vector<int> GistRed(256);
	long int CoefBlue = 0;
	long int CoefGreen = 0;
	long int CoefRed = 0;
	split(image, temp);
	for (int i = 0; i < image.rows; i++)
	{
		for (int j = 0; j < image.cols; j++)
		{
			GistBlue[(temp[0].at<uchar>(i, j))]++;
			GistGreen[(temp[1].at<uchar>(i, j))]++;
			GistRed[(temp[2].at<uchar>(i, j))]++;
		}
	}
	long int percent = image.rows*image.cols*proc / 100;
	for (int i = 0; i < 255; i++)
	{
		CoefBlue += GistBlue[i];
		CoefGreen += GistGreen[i];
		CoefRed += GistRed[i];

		if (CoefBlue >= percent || CoefGreen >= percent || CoefRed >= percent)
		{
			min = i;
			break;
		}
	}
	CoefBlue = 0; CoefGreen = 0; CoefRed = 0;
	for (int i = 255; i > 0; i--)
	{
		CoefBlue += GistBlue[i];
		CoefGreen += GistGreen[i];
		CoefRed += GistRed[i];
		if (CoefBlue >= percent || CoefGreen >= percent || CoefRed >= percent)
		{
			max = i;
			break;
		}
	}
}


int main()
{

	//create GUI windows
	namedWindow("Frame");
	namedWindow("frameColCor");
	namedWindow("binarMask");
	namedWindow("BS");
	namedWindow("BS_canny");
	namedWindow("BS2");

	//create Background Subtractor objects
	pMOG = createBackgroundSubtractorMOG2(); //MOG2 approach
	pMOG.dynamicCast<BackgroundSubtractorMOG2>()->setShadowValue(0);
	//pMOG.dynamicCast<BackgroundSubtractorMOG2>()->setHistory(33);
	//pMOG.dynamicCast<BackgroundSubtractorMOG2>()->setNMixtures(10);
	//pMOG.dynamicCast<BackgroundSubtractorMOG2>()->setDetectShadows(false);
	pMOG.dynamicCast<BackgroundSubtractorMOG2>()->setShadowThreshold(0.1);
	setMouseCallback("Frame", onMouse);

	processVideo("MVI_6114.avi");
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}


void processVideo(char* videoFilename) {

	Mat binarMask; //fg mask fg mask generated by MOG2 method
	Mat copyFrame; //frame rect
	Mat frameColCor; //frame rect
	Mat frame_top; //frame
	Mat frame_bottom; //frame
	Mat frame_middle1; //frame
	Mat frame_middle2; //frame
	Mat frameCanny; //frame
	Mat BS; //frame bs
	Mat BS_canny; //frame bs
	Mat BS2; //frame bs
	int index = 0;
	string str_out = "";

	ofstream out("out.txt");
	out.clear();
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << endl;
		exit(EXIT_FAILURE);
	}
	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;
	vector<Vec4i> lines;
	capture.read(primeFrame);
	copyFrame = primeFrame(rect_for_frame).clone();
	Canny(copyFrame, frameCanny, 255, 255, 3);

	int min = 0, max = 0;
	slider(primeFrame, min, max, 20);
	//read input data. ESC or 'q' for quitting

	while ((char)keyboard != 'q' && (char)keyboard != 27){
		//read the current frame
		if (!capture.read(primeFrame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		frameColCor = primeFrame(rect_for_frame).clone();
		copyFrame = primeFrame(rect_for_frame).clone();
		for (int i = 0; i < frameColCor.rows; i++)
		{
			for (int j = 0; j < frameColCor.cols; j++)
			{
				frameColCor.at<Vec3b>(i, j)[0] = saturate_cast<uchar>((double)
					(((double)frameColCor.at<Vec3b>(i, j)[0] - (double)min) / (double)(max - min)) * 255);
				frameColCor.at<Vec3b>(i, j)[1] = saturate_cast<uchar>((double)
					(((double)frameColCor.at<Vec3b>(i, j)[1] - (double)min) / (double)(max - min)) * 255);
				frameColCor.at<Vec3b>(i, j)[2] = saturate_cast<uchar>((double)
					(((double)frameColCor.at<Vec3b>(i, j)[2] - (double)min) / (double)(max - min)) * 255);
			}
		}
		//GaussianBlur(frameColCor, frameColCor, Size(5, 5), 255, 255);

		pMOG->apply(frameColCor, binarMask);

		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frameColCor, Point(10, 2), Point(10, 20),
			Scalar(255, 255, 255), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frameColCor, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 255));

		BS = binarMask.clone();
		BS2 = binarMask.clone();
		Canny(frameColCor, frameCanny, 255, 255, 3);
		//HoughLines(frameCanny, lines, 1, CV_PI / 180, 80, 30, 10);
		Mat bs_ = BS.clone();
		findContours(bs_, contours, hierarchy,
			CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);
		//cout << contours.size() << endl;
		for (int i = 0, minx = 1000, maxx = -1, miny = 1000, maxy = -1; i < contours.size(); i++)
		{
			minx = 1000; maxx = -1; miny = 1000; maxy = -1;
			for (int j = 0; j < contours[i].size(); j++)
			{
				if (minx > contours[i][j].x) minx = contours[i][j].x;
				if (miny > contours[i][j].y) miny = contours[i][j].y;
				if (maxx < contours[i][j].x) maxx = contours[i][j].x;
				if (maxy < contours[i][j].y) maxy = contours[i][j].y;
			}
			for (int k = 0, minx2 = 1000, maxx2 = -1, miny2 = 1000, maxy2 = -1; k < contours.size(); k++)
			{
				minx2 = 1000; maxx2 = -1; miny2 = 1000; maxy2 = -1;
				for (int j = 0; j < contours[k].size(); j++)
				{
					if (minx2 > contours[k][j].x) minx2 = contours[k][j].x;
					if (miny2 > contours[k][j].y) miny2 = contours[k][j].y;
					if (maxx2 < contours[k][j].x) maxx2 = contours[k][j].x;
					if (maxy2 < contours[k][j].y) maxy2 = contours[k][j].y;
				}
				if (minx2 >= minx && maxx2 <= maxx && miny2 >= miny && maxy2 <= maxy && k != i)
				{
					rectangle(BS2, Rect(Point(minx2, miny2), Point(maxx2, maxy2)), 255, -1, 8, 0);

				}
			}

		}
		binarMask = BS2.clone();
		frame_top = binarMask(rect_for_top);
		frame_middle1 = binarMask(rect_for_middle1);
		frame_middle2 = binarMask(rect_for_middle2);
		frame_bottom = binarMask(rect_for_bottom);

		medianBlur(frame_top, frame_top, 15);
		medianBlur(frame_middle1, frame_middle1, 37);
		medianBlur(frame_middle2, frame_middle2, 43);
		medianBlur(frame_bottom, frame_bottom, 51);
		medianBlur(binarMask, binarMask, 5);
		Canny(binarMask, BS_canny, 255, 255, 3);

		Canny(copyFrame, frameCanny, 255, 255, 3);

		//Canny(binarMask, binarMask, 255, 255, 3);
		//medianBlur(BS, binarMask, 3);
		
		bs_ = binarMask.clone();
		findContours(bs_, contours, hierarchy,
			CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);
		cout << contours.size() << endl;


		for (int i = 0, minx = 1000, maxx = -1, miny = 1000, maxy = -1; i < contours.size(); i++)
		{
			minx = 1000; maxx = -1; miny = 1000; maxy = -1;
			for (int j = 0; j < contours[i].size(); j++)
			{
				if (minx > contours[i][j].x) minx = contours[i][j].x;
				if (miny > contours[i][j].y) miny = contours[i][j].y;
				if (maxx < contours[i][j].x) maxx = contours[i][j].x;
				if (maxy < contours[i][j].y) maxy = contours[i][j].y;
			}
			if ((maxx - minx)>25 && (maxy - miny)>25)
			{
				(miny - 0.15*(maxy - miny) < 0) ? miny = 0 : miny -= 0.15 * (maxy - miny);
				(maxy - 0.15*(maxy - miny) < 0) ? maxy = 0 : maxy -= 0.15 * (maxy - miny);

				rectangle(copyFrame, Rect(Point(minx, miny), Point(maxx, maxy)), Scalar(50, 200, 5), 3, 8, 0);
				drawContours(copyFrame, contours, i, Scalar(255, 0, 255), 1);
				cout << contours[i].size() << endl;
				if ((maxx - minx)>50 && (maxy - miny)>50)// && (maxx - minx)>50 && (maxy - miny)>50)
				{
					Mat print = primeFrame(Rect(Point(minx + rect_for_frame.x, maxy - 200 + rect_for_frame.y > 0 ? maxy - 200 + rect_for_frame.y : 0),
						Point(minx + 100 + rect_for_frame.x < primeFrame.rows ? minx + 100 + rect_for_frame.x : primeFrame.rows, maxy + rect_for_frame.y)));
					//imshow("print" , print);
					string str1 = "C:/image/ImageGT";
					string str2 = to_string(numberOfprint);
					numberOfprint++;
					string str3 = ".jpg";
					str1 += str2;
					str1 += str3;
					if (print.cols == 100 && print.rows == 200)
					{
						imwrite(str1, print);
					}
					if (index != (atoi(frameNumberString.c_str()) / 25))
					{
						index = atoi(frameNumberString.c_str()) / 25;
						str_out = "Gruz " + to_string(atoi(frameNumberString.c_str()) / 25);
						out << str_out << endl;
					}
				}
				//if ((maxx - minx) > 50 && (maxy - miny) < 80)// && (maxx - minx)>50 && (maxy - miny)>50)
				//{
				//	if (index != (atoi(frameNumberString.c_str()) / 25))
				//	{
				//		index = atoi(frameNumberString.c_str()) / 25;
				//		str_out = "Legk " + to_string(atoi(frameNumberString.c_str()) / 25);
				//		out << str_out << endl;
				//	}
				//}
			}
		}


		imshow("copyFrame", copyFrame);
		imshow("frameCanny", frameCanny);
		imshow("binarMask", binarMask);
		imshow("BS", BS);
		imshow("BS_canny", BS_canny);
		imshow("BS2", BS2);
		imshow("frameColCor", frameColCor);
		imshow("Frame", primeFrame);


		//get the input from the keyboard
		keyboard = (char)waitKey(30);

	}
	//delete capture object
	out.close();
	capture.release();
}



void onMouse(int event, int x, int y, int, void*)
{
	static int countP = 0;
	static vector<Point> VP;

	if (event != EVENT_LBUTTONDOWN)
		return;
	Point seed = Point(x, y);
	countP++;
	cout << seed.x << "  " << seed.y;
	VP.push_back(seed);
	if (countP == 2)
	{
		int width = 0,
			height = 0;
		Point P;
		height = abs(VP[0].y - VP[1].y);
		width = abs(VP[0].x - VP[1].x);
		VP[0].x < VP[1].x ? P.x = VP[0].x : P.x = VP[1].x;
		VP[0].y < VP[1].y ? P.y = VP[0].y : P.x = VP[1].y;

		rect_for_frame.x = P.x;
		rect_for_frame.y = P.y;
		rect_for_frame.width = width;
		rect_for_frame.height = height;

		rect_for_top.x = 0;
		rect_for_top.y = 0;
		rect_for_top.width = width;
		rect_for_top.height = height / 4;

		rect_for_middle1.x = 0;
		rect_for_middle1.y = height / 4;
		rect_for_middle1.width = width;
		rect_for_middle1.height = height / 4;

		rect_for_middle2.x = 0;
		rect_for_middle2.y = height / 2;
		rect_for_middle2.width = width;
		rect_for_middle2.height = height / 4;

		rect_for_bottom.x = 0;
		rect_for_bottom.y = height / 4 * 3;
		rect_for_bottom.width = width;
		rect_for_bottom.height = height / 4;

		setMouseCallback("original", NULL, NULL);

	}

}
